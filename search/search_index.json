{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>When migrating to ambient mesh, one of the concerns that engineering teams face is the scenario where their existing mesh configurations include the use of EnvoyFilters.</p> <p>An example is rate limiting, a feature that Istio does not natively provide a custom resource definition for. To apply Envoy rate limiting in Istio, users must employ an EnvoyFilter.</p> <p>In ambient mode, there are better ways to solve this problem. Waypoints play the role of microgateways that proxy mesh services. In ambient mode, we can plug in an alternative waypoint implementation that does provide native support for rate limiting (or whatever specific API engineering teams are looking to implement).</p> <p>For example, solo.io's kgateway project provides first-class support for rate limiting. Plugging in kgateway as a waypoint allows us to eschew ourselves of the use of EnvoyFilters.</p> <p>Nevertheless, when performing a migration to ambient mode, as a first step, it is desirable to be able to migrate existing resources \"as is.\"</p> <p>Open-source Istio does not support EnvoyFilters for waypoints. Solo.io however provides builds of Istio that do.</p> <p>In this exercise, you will start with an Istio installation in sidecar mode, and configure an Envoy Filter for local rate limiting, and test it.</p> <p>Next, we will walk through upgrading Istio to use Solo.io's build, and migrate to ambient mode. In the process, we will demonstrate the continued functioning of the EnvoyFilter post-migration.</p>"},{"location":"migrate/","title":"Migrate to ambient mode","text":""},{"location":"migrate/#upgrade-istio-to-ambient","title":"Upgrade Istio to ambient","text":"<pre><code>istioctl install --set profile=ambient --set values.global.platform=k3d --skip-confirmation\n</code></pre> <p>Verify that, in <code>istio-system</code> namespace we now have added Istio components necessary for ambient mode:  the Istio CNI node agent, and the ztunnel Daemonset.</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> <pre><code>NAME                      READY   STATUS    RESTARTS   AGE\nistio-cni-node-64xj2      1/1     Running   0          74s\nistiod-77f86b5796-5ksqz   1/1     Running   0          106s\nztunnel-f84rm             1/1     Running   0          50s\n</code></pre>"},{"location":"migrate/#install-the-kubernetes-gateway-api","title":"Install the Kubernetes Gateway API","text":"<p>Istio ambient mode requires the Kubernetes Gateway API.</p> <p>Install the standard channel CRDs:</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml\n</code></pre>"},{"location":"migrate/#checkpoint","title":"Checkpoint","text":"<p>At this point, the EnvoyFilter continues to function because the workloads still have sidecars.</p> <p>Verify this:</p> <pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>You should still see the fifth call return an HTTP 429 (Rate-limited).</p>"},{"location":"migrate/#migrate-the-data-plane","title":"Migrate the data plane","text":"<p>To migrate the workloads to ambient:</p> <ol> <li> <p>Remove the <code>istio-injection</code> labels:</p> <pre><code>kubectl label namespace httpbin istio-injection-\n</code></pre> </li> <li> <p>Add the <code>dataplane-mode</code> label</p> <pre><code>kubectl label namespace httpbin istio.io/dataplane-mode=ambient\n</code></pre> <p>This label will ensure that ztunnel intercepts traffic in and out of our workloads.</p> </li> <li> <p>Remove the sidecars by restarting the workloads:</p> <pre><code>kubectl rollout restart deploy -n httpbin\n</code></pre> </li> </ol> <p>Verify that the workloads no longer bear sidecars:</p> <pre><code>kubectl get pod -n httpbin\n</code></pre> <pre><code>NAME                       READY   STATUS    RESTARTS   AGE\ncurl-5d7946555f-ts24c      1/1     Running   0          10s\nhttpbin-7dbddd7b86-7mx6b   1/1     Running   0          10s\n</code></pre> <p>Inspect the workloads to ascertain that they use the HBONE protocol:</p> <pre><code>istioctl ztunnel-config workload\n</code></pre> <pre><code>NAMESPACE    POD NAME                  ADDRESS      NODE                    WAYPOINT PROTOCOL\nhttpbin      curl-5d7946555f-ts24c     10.42.0.14   k3d-my-cluster-server-0 None     HBONE\nhttpbin      httpbin-7dbddd7b86-7mx6b  10.42.0.15   k3d-my-cluster-server-0 None     HBONE\n...\n</code></pre>"},{"location":"migrate/#test-rate-limiting","title":"Test rate-limiting","text":"<p>This time you will notice that the EnvoyFilter has stopped functioning:</p> <pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>This makes perfect sense:  ztunnel is in the path of requests to <code>httpbin</code>, but an EnvoyFilter requires a waypoint.</p>"},{"location":"migrate/#add-the-waypoint","title":"Add the waypoint","text":"<p>Per the documentation on ambientmesh.io, we can deploy a waypoint to the <code>httpbin</code> namespace with the command:</p> <pre><code>istioctl waypoint apply -n httpbin --enroll-namespace\n</code></pre> <p>Note the <code>--enroll-namespace</code> option which automatically binds workloads in that namespace to the waypoint.</p> <p>The output confirms the operation:</p> <pre><code>\u2705 waypoint httpbin/waypoint applied\n\u2705 namespace httpbin labeled with \"istio.io/use-waypoint: waypoint\"\n</code></pre> <p>You can also see the waypoint running in the <code>httpbin</code> namespace:</p> <pre><code>kubectl get pod -n httpbin\n</code></pre> <pre><code>NAME                        READY   STATUS    RESTARTS   AGE\ncurl-5d7946555f-ts24c       1/1     Running   0          10m\nhttpbin-7dbddd7b86-7mx6b    1/1     Running   0          10m\nwaypoint-7d4fdb5b7c-rlq57   1/1     Running   0          63s\n</code></pre>"},{"location":"migrate/#another-checkpoint","title":"Another checkpoint","text":"<p>Now that we have a waypoint fronting <code>httpbin</code>, let's test rate-limiting again:</p> <pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>We discover that rate limiting is still not functioning.</p> <p>The reason is that EnvoyFilter is not supported in open-source Istio in ambient mode (i.e. applied to waypoints).</p> <p>Thankfully, solo.io provides builds of Istio that do.</p>"},{"location":"migrate/#upgrade-to-solos-build","title":"Upgrade to Solo's build","text":"<p>The ambientmesh.io documentation provides the instructions for using Solo's builds.</p> <p>Upgrade Istio by overriding the <code>hub</code> and <code>tag</code> configuration options.  <code>hub</code> tells the Istio CLI to fetch images from a different location, while the <code>tag</code> option specifies the version to use:</p> <pre><code>istioctl install --set profile=ambient --set values.global.platform=k3d --skip-confirmation \\\n  --set hub=us-docker.pkg.dev/soloio-img/istio \\\n  --set tag=1.26.1-solo\n</code></pre> <p>Verify that Istio's version is now the Solo version:</p> <pre><code>istioctl version\n</code></pre> <pre><code>client version: 1.26.1\ncontrol plane version: 1.26.1-solo\ndata plane version: 1.26.1-solo (2 proxies)\n</code></pre>"},{"location":"migrate/#verify-rate-limiting-once-more","title":"Verify rate-limiting once more","text":"<p>Re-run the test command:</p> <pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>The rate limiting is still not working. We need to apply one final change.</p>"},{"location":"migrate/#retrofit-the-envoyfilter-spec","title":"Retrofit the EnvoyFilter spec","text":"<p>In sidecar mode the EnvoyFilter targeted the service via the <code>workloadSelector</code> field. In ambient mode, the EnvoyFilter must reference the waypoint via the <code>targetRefs</code> field.</p> <p>Here is a revised envoy filter for ambient:</p> envoyfilter-ambient.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: filter-local-ratelimit-svc\nspec:\n  targetRefs:\n  - kind: Service\n    name: httpbin\n  configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n        listener:\n          filterChain:\n            filter:\n              name: \"envoy.filters.network.http_connection_manager\"\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: envoy.filters.http.local_ratelimit\n          typed_config:\n            \"@type\": type.googleapis.com/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit\n            value:\n              stat_prefix: http_local_rate_limiter\n              token_bucket:\n                max_tokens: 4\n                tokens_per_fill: 4\n                fill_interval: 60s\n              filter_enabled:\n                runtime_key: local_rate_limit_enabled\n                default_value:\n                  numerator: 100\n                  denominator: HUNDRED\n              filter_enforced:\n                runtime_key: local_rate_limit_enforced\n                default_value:\n                  numerator: 100\n                  denominator: HUNDRED\n              response_headers_to_add:\n                - append: false\n                  header:\n                    key: x-local-rate-limit\n                    value: 'true'\n</code></pre> <p>Apply the updated EnvoyFilter:</p> <pre><code>kubectl apply -n httpbin -f artifacts/envoyfilter-ambient.yaml\n</code></pre>"},{"location":"migrate/#re-test","title":"Re-test","text":"<pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>You will see four HTTP 200 responses, while the fifth request returned:</p> <pre><code>command terminated with exit code 56\n</code></pre> <p>Inspect the ztunnel logs:</p> <pre><code>kubectl logs -n istio-system -l app=ztunnel\n</code></pre> <p>The last line should indicate that the request was rate-limited:</p> <pre><code>2025-06-06T05:48:08.499364Z     error   access  connection complete     \nsrc.addr=10.42.0.14:52486 src.workload=\"curl-5d7946555f-ts24c\" \nsrc.namespace=\"httpbin\" src.identity=\"spiffe://cluster.local/ns/httpbin/sa/curl\" \ndst.addr=10.42.0.18:15008 dst.hbone_addr=10.43.9.128:8000 \ndst.service=\"httpbin.httpbin.svc.cluster.local\" dst.workload=\"waypoint-66465f7777-d5xwd\" \ndst.namespace=\"httpbin\" dst.identity=\"spiffe://cluster.local/ns/httpbin/sa/waypoint\" \ndirection=\"outbound\" bytes_sent=0 bytes_recv=0 duration=\"0ms\"\nerror=\"http status: 429 Too Many Requests\"\n</code></pre>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#install-istio-in-sidecar-mode","title":"Install Istio in sidecar mode","text":"<pre><code>istioctl install --set values.global.platform=k3d\n</code></pre>"},{"location":"setup/#deploy-the-httpbin-sample-application","title":"Deploy the <code>httpbin</code> sample application","text":"<p>Create the namespace, configure it for sidecar injection, and deploy the workload:</p> <pre><code>kubectl create ns httpbin\nkubectl label ns httpbin istio-injection=enabled\nkubectl apply -n httpbin -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/httpbin/httpbin.yaml\n</code></pre> <p>Verify that the workload is running and has two containers (that sidecar injection took place):</p> <pre><code>kubectl get pod -n httpbin\n</code></pre> <p>Deploy a <code>curl</code> client to test <code>httpbin</code>:</p> <pre><code>kubectl apply -n httpbin -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/curl/curl.yaml\n</code></pre> <p>Send a test request to <code>httpbin</code>:</p> <pre><code>kubectl exec -n httpbin deploy/curl -- curl -s httpbin:8000/get\n</code></pre>"},{"location":"setup/#apply-an-envoyfilter","title":"Apply an EnvoyFilter","text":"<p>For this example, we wish to apply local rate limiting to <code>httpbin</code>.</p> <p>The Istio documentation provides an example which we can adapt for our scenario:</p> envoyfilter.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: filter-local-ratelimit-svc\nspec:\n  workloadSelector:\n    labels:\n      app: httpbin\n  configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n        listener:\n          filterChain:\n            filter:\n              name: \"envoy.filters.network.http_connection_manager\"\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: envoy.filters.http.local_ratelimit\n          typed_config:\n            \"@type\": type.googleapis.com/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit\n            value:\n              stat_prefix: http_local_rate_limiter\n              token_bucket:\n                max_tokens: 4\n                tokens_per_fill: 4\n                fill_interval: 60s\n              filter_enabled:\n                runtime_key: local_rate_limit_enabled\n                default_value:\n                  numerator: 100\n                  denominator: HUNDRED\n              filter_enforced:\n                runtime_key: local_rate_limit_enforced\n                default_value:\n                  numerator: 100\n                  denominator: HUNDRED\n              response_headers_to_add:\n                - append: false\n                  header:\n                    key: x-local-rate-limit\n                    value: 'true'\n</code></pre> <p>Per the example documentation, the EnvoyFilter enables local rate limiting for traffic to the <code>httpbin</code> service. The <code>HTTP_FILTER</code> patch inserts the <code>envoy.filters.http.local_ratelimit</code> local envoy filter into the HTTP connection manager filter chain. The local rate limit filter\u2019s token bucket is configured to allow 4 requests per minute. The filter is also configured to add an <code>x-local-rate-limit</code> response header to requests that are blocked.</p> <p>Apply the EnvoyFilter:</p> <pre><code>kubectl apply -n httpbin -f artifacts/envoyfilter.yaml\n</code></pre>"},{"location":"setup/#validate","title":"Validate","text":"<p>Verify that the filter functions.</p> <pre><code>for i in {1..5}; do kubectl exec -n httpbin deploy/curl -- curl -s --head httpbin:8000/json; done\n</code></pre> <p>The output will show four consecutive HTTP 200 (Success) responses, followed by a rate-limited response:</p> <pre><code>HTTP/1.1 200 OK\naccess-control-allow-credentials: true\naccess-control-allow-origin: *\ncontent-type: application/json; charset=utf-8\ndate: Fri, 06 Jun 2025 04:34:32 GMT\nx-envoy-upstream-service-time: 0\nserver: envoy\ntransfer-encoding: chunked\n\n...\n\nHTTP/1.1 429 Too Many Requests\nx-local-rate-limit: true\ncontent-length: 18\ncontent-type: text/plain\ndate: Fri, 06 Jun 2025 04:34:32 GMT\nserver: envoy\nx-envoy-upstream-service-time: 1\n</code></pre> <p>Note the added <code>x-local-rate-limit</code> header in the response which came from the configuration of our EnvoyFilter.</p>"},{"location":"setup/#next","title":"Next..","text":"<p>We wish migrate to ambient mode without losing this capability.</p> <p>Next, we turn our attention to this migration task.</p>"}]}